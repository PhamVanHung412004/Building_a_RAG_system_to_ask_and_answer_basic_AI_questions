Reinforcement Learning
Markov Decision Processes
Instructor: Ngoc-Hoang LUONG, PhD.
[These slides were adapted from the slides created by Dan Klein and Pieter Abbeel for CS188 Intro to AI at UC Berkeley. http://ai.berkeley.edu.]
Behavior from Computation
Video of Demo Mystery Pacman
Adversarial Games
A simple game
â–ªYou choose one of the three bins.
â–ªI choose a number from that bin.
â–ªYour goal is to maximize the chosen number.
A
-$50
$50
B
$1 $5
C
-$10
$20
Game tree
â–ªEach node is a decision point for a player.
â–ªEach root-to-leaf path is a possible outcome of the game.
â–ªYour goal is to maximize the chosen number.
Adversarial Search
Single-Agent Trees
8
2
0
2
6
4
6
â€¦
â€¦
Value of a State
Non-Terminal States:
8
2
0
2
6
4
6
â€¦
â€¦
Terminal States:
Value of a state: 
The best achievable 
outcome (utility) 
from that state
Adversarial Game Trees
-20
-8
-18
-5
-10
+4
â€¦
â€¦
-20
+8
Minimax Values
+8
-10
-5
-8
States Under Agentâ€™s Control:
Terminal States:
States Under Opponentâ€™s Control:
Tic-Tac-Toe Game Tree
X O X
O O X
X O X
O O X
X
X O X
O O X
X
X O X
O O X
X
X O X
O O X
X O
X O X
O O X
X
O
X O X
O O X
X X O
X O X
O O X
O X
X O X
O O X
X O
X O X
O O X
O X X
X O X
O O X
X X O
-1
0
0
-1
+1
0
+1
0
0
+1
+1
Xâ€™s turn (MAX)
Oâ€™s turn (MIN)
Xâ€™s turn (MAX)
Adversarial Search (Minimax)
â–ªDeterministic, zero-sum games:
â–ªTic-tac-toe, chess, checkers
â–ªOne player maximizes result
â–ªThe other minimizes result
â–ªMinimax search:
â–ªA state-space search tree
â–ªPlayers alternate turns
â–ªCompute each nodeâ€™s minimax value: 
the best achievable utility against a 
rational (optimal) adversary
8
2
5
6
max
min
2
5
5
Terminal values:
part of the game 
Minimax values:
computed recursively
Minimax Efficiency
â–ªHow efficient is minimax?
â–ªJust like (exhaustive) DFS
â–ªTime: O(bm)
â–ªSpace: O(bm)
â–ªExample: For chess, b â‰ˆ 35, m â‰ˆ 100
â–ªExact solution is completely infeasible
â–ªBut, do we need to explore the whole 
tree?
Resource Limits
Resource Limits
â–ªProblem: In realistic games, cannot search to leaves!
â–ªSolution: Depth-limited search
â–ªInstead, search only to a limited depth in the tree
â–ªReplace terminal utilities with an evaluation function for 
non-terminal positions
â–ªExample:
â–ªSuppose we have 100 seconds, can explore 10K nodes / sec
â–ªSo can check 1M nodes per move
â–ªÎ±-Î² reaches about depth 8 â€“ decent chess program
â–ªGuarantee of optimal play is gone
â–ªMore plies makes a BIG difference
â–ªUse iterative deepening for an anytime algorithm
?
?
?
?
-1
-2
4
9
4
min
max
-
2
4
Evaluation Functions
â–ªEvaluation functions score non-terminals in depth-limited search
â–ªIdeal function: returns the actual minimax value of the position
â–ªIn practice: typically weighted linear sum of features:
â–ªe.g.  f1(s) = (num white queens â€“ num black queens), etc.
Video of Demo Limited Depth (2)
Video of Demo Limited Depth (10)
Minimax Properties
â–ªYou choose one of the three bins.
â–ªI toss a fair coin. If head, the bigger number is 
returned. If tail, the smaller number is returned.
â–ªYour goal is to maximize the chosen number.
A
-$50
$50
B
$1 $5
C
-$10
$20
Minimax Properties
â–ªYou choose one of the three bins.
â–ªI toss a fair coin. If head, the bigger number is 
returned. If tail, the smaller number is returned.
â–ªYour goal is to maximize the chosen number.
Minimax Properties
Optimal against a perfect player.  Otherwise?
1
0
1
0
9
1
0
0
max
min
Video of Demo Min vs. Exp (Min)
Video of Demo Min vs. Exp (Exp)
Expectimax Search
â–ªWhy wouldnâ€™t we know what the result of an action will be?
â–ªExplicit randomness: rolling dice
â–ªUnpredictable opponents: the ghosts respond randomly
â–ªActions can fail: when moving a robot, wheels might slip
â–ªValues should now reflect average-case (expectimax) 
outcomes, not worst-case (minimax) outcomes
â–ªExpectimax search: compute the average score under 
optimal play
â–ªMax nodes as in minimax search
â–ªChance nodes are like min nodes but the outcome is uncertain
â–ªCalculate their expected utilities
â–ªI.e. take weighted average (expectation) of children
â–ªLater, weâ€™ll learn how to formalize the underlying 
uncertain-result problems as Markov Decision Processes
1
0
4
5
7
max
chance
1
0
1
0
9
1
0
0
Expectimax Example
12
9
6
0
3
2
15
4
6
8
4
7
8
Non-Deterministic Search
Example: Grid World
â–ª
A maze-like problem
â–ª
The agent lives in a grid
â–ª
Walls block the agentâ€™s path
â–ª
Noisy movement: actions do not always go as planned
â–ª
80% of the time, the action North takes the agent North 
(if there is no wall there)
â–ª
10% of the time, North takes the agent West; 10% East
â–ª
If there is a wall in the direction the agent would have been 
taken, the agent stays put
â–ª
The agent receives rewards each time step
â–ª
Small â€œlivingâ€ reward each step (can be negative)
â–ª
Big rewards come at the end (good or bad)
â–ª
Goal: maximize sum of rewards
Grid World Actions
Deterministic Grid World
Stochastic Grid World
Markov Decision Processes
â–ªAn MDP is defined by:
â–ªA set of states s âˆˆ S
â–ªA set of actions a âˆˆ A
â–ªA transition function T(s, a, sâ€™)
â–ªProbability that a from s leads to sâ€™, i.e., P(sâ€™| s, a)
â–ªAlso called the model or the dynamics
â–ªA reward function R(s, a, sâ€™) 
â–ªSometimes just R(s) or R(sâ€™)
â–ªA start state
â–ªMaybe a terminal state
â–ªMDPs are non-deterministic search problems
â–ªOne way to solve them is with expectimax search
â–ªWeâ€™ll have a new tool soon
What is Markov about MDPs?
â–ªâ€œMarkovâ€ generally means that given the present state, the 
future and the past are independent
â–ªFor Markov decision processes, â€œMarkovâ€ means action 
outcomes depend only on the current state
Andrey Markov 
(1856-1922)
Policies
Optimal policy when R(s, a, sâ€™) = -0.03 
for all non-terminals s
â–ªIn deterministic single-agent search problems, 
we wanted an optimal plan, or sequence of 
actions, from start to a goal
â–ªA policy Ï€: S â†’ A gives an action for each 
state.
â–ªE.g, Ï€((1,1)) = â€œnorthâ€, Ï€((4,1)) = â€œwestâ€, Ï€
((3,3))=â€œeastâ€, Ï€((3,2))=â€œnorthâ€,â€¦
â–ªFor MDPs, we want an optimal policy Ï€*: S â†’ 
A
â–ªAn optimal policy is one that maximizes        expected 
utility if followed
Policy
(1,1)
(3,3)
(4,1)
Example: Bridge Crossing
Example: Volcano
123RF.com
shutterstock.com
MDP Search Tree
action a = â€œsouthâ€
state s = (2,2) 
 
 
 
 
 
 
 
 
MDP Search Tree
action a = â€œeastâ€
state s = (2,2) 
 
 
 
 
 
 
 
MDP Search Tree
action a = â€œeastâ€
state s = (4,1) 
 
 
 
 
 
 
 
MDP Search Trees
â–ªEach MDP state projects an expectimax-like search tree
a
s
â€™s
s, a
(s,a,sâ€™) called a transition
T(s,a,sâ€™) = P(sâ€™|s,a)
R(s,a,sâ€™)
s,a,sâ€™
s is a state
(s, a) is a 
q-state
Optimal Policies
R(s) = -2.0
R(s) = -0.4
R(s) = -0.03
R(s) = -0.01
R(s) = the â€œliving rewardâ€
Policy Evaluation
Example: Policy Evaluation
Always Go Right
Always Go Forward
Example: Policy Evaluation
 
 
State
Action
(2,1)
â€œeastâ€
(2,2)
â€œeastâ€
(2,3)
â€œeastâ€
(2,4)
â€œexitâ€
(1,3)
â€œexitâ€
â€¦
â€¦
 
 
State
Action
(2,1)
â€œnorthâ€
(2,2)
â€œnorthâ€
(2,3)
â€œnorthâ€
(2,4)
â€œexitâ€
(1,3)
â€œexitâ€
â€¦
â€¦
 
 
Example: Policy Evaluation
 
 
State
Action
Value
(2,1)
â€œeastâ€
-9.06
(2,2)
â€œeastâ€
-8.25
(2,3)
â€œeastâ€
0.76
(2,4)
â€œexitâ€
100
(1,3)
â€œexitâ€
-10
â€¦
â€¦
â€¦
 
 
State
Action
Value
(2,1)
â€œnorthâ€
32.62
(2,2)
â€œnorthâ€
48.23
(2,3)
â€œnorthâ€
69.60
(2,4)
â€œexitâ€
100
(1,3)
â€œexitâ€
-10
â€¦
â€¦
â€¦
 
 
 
 
 
Policy Evaluation
â–ª 
 
 
Utility of a sequence of actions
 
Exit
 
Living Reward = 0, Noise = 0
Utility of a sequence of actions
 
Exit
 
Living Reward = -0.3, Noise = 0.0
 
Utility of a sequence of actions
 
Exit
Living Reward = -0.3, Noise = 0.2
Exit
 
 
 
 
Utilities of Sequences
Utilities of Sequences
â–ªWhat preferences should an agent have over reward sequences?
â–ªMore or less?
â–ªNow or later?
[1, 2, 2]
[2, 3, 4]
 or
[0, 0, 1]
[1, 0, 0]
 or
Discounting
â–ªItâ€™s reasonable to maximize the sum of rewards
â–ªItâ€™s also reasonable to prefer rewards now to rewards later
â–ªOne solution: values of rewards decay exponentially
Worth Now
Worth Next Step
Worth In Two Steps
Discounting
â–ªHow to discount?
â–ªEach time we descend a level, we 
multiply in the discount once
â–ªWhy discount?
â–ªSooner rewards probably do have 
higher utility than later rewards
â–ªAlso helps our algorithms converge
â–ªExample: discount of 0.5
â–ªU([1,2,3]) = 1*1 + 0.5*2 + 0.25*3
â–ªU([1,2,3]) < U([3,2,1])
Utility of a sequence of actions
 
Exit
Living Reward = -0.3, Noise = 0.0
 
Exit
 
 
Utility of a sequence of actions
 
Exit
Living Reward = -0.3, Noise = 0.2
 
 
 
Exit
 
Exit
 
Exit
 
Solving MDPs
Policy Evaluation
Policy Evaluation
state s = (2,2) 
Regarding the current state, 
how good is it according to a policy Ï€?
Policy Evaluation
action a = â€œsouthâ€
state s = (2,2) 
 
 
 
 
 
 
 
 
 
 
 
Expected Utility of taking action 
a=â€œsouthâ€ in state s = (2,2)
= ?
expected utility 
of state (1,2)
expected utility 
of state (2,1)
expected utility 
of state (3,2)
 
 
 
?
 
 
 
expected utility 
of state (1,2)
by following ğœ‹ 
expected utility 
of state (2,1)
by following ğœ‹
expected utility 
of state (3,2)
by following ğœ‹
Expected Utility of taking action 
a=â€œsouthâ€ in state s = (2,2)
and then following ğœ‹
 
 
 
 
State
Action
(2,2)
â€œsouthâ€
(1,2)
â€œeastâ€
(2,1)
â€œeastâ€
(3,2)
â€œexitâ€
â€¦
â€¦
 
Exit
Policy Evaluation
â–ª 
 
 
 
Ï€(s)
s
s, Ï€(s)
s, Ï€(s),sâ€™
â€™s
 
 
a
s
s, a
s,a,sâ€™
â€™s
 
 
Policy Evaluation
 
[2,1]
â€œeastâ€
[2,2]
â€œeastâ€
[2,3]
â€œeastâ€
[2,4]
â€œexitâ€
[1,3]
â€œexitâ€
â€¦
â€¦
 
 
 
 
 
 
 
Solving a system of linear equations
(Iterative) Policy Evaluation
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Iterative Approach
Example: Policy Evaluation
Always Go Right
Always Go Forward
Example: Policy Evaluation
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
 
(2,1)
â€œeastâ€
(2,2)
â€œeastâ€
(2,3)
â€œeastâ€
(2,4)
â€œexitâ€
(1,3)
â€œexitâ€
â€¦
â€¦
 
(2,1)
â€œnorthâ€
(2,2)
â€œnorthâ€
(2,3)
â€œnorthâ€
(2,4)
â€œexitâ€
(1,3)
â€œexitâ€
â€¦
â€¦
 
t=0
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
t=0 ğŸ¡ª t=1
 
 
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
t=1 ğŸ¡ª t=2
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
t=2 ğŸ¡ª t=3
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
t=3 ğŸ¡ª t=4
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
t=4 ğŸ¡ª t=5
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
t=5 ğŸ¡ª t=6
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
t=6 ğŸ¡ª t=7
 
 
 
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
 
Example: Policy Evaluation
 
 
Noise = 0.2
Discount = 0.9
Living reward = -0.3
 
 
 
Summary: Policy Evaluation
â–ª 
Ï€(s)
s
s, Ï€(s)
s, Ï€(s),sâ€™
â€™s
 
 
 
Value Iteration
Policy Evaluation
state s = (2,2) 
Regarding the current state, 
how good is it according to a policy Ï€?
Value Iteration
state s = (2,2) 
Regarding the current state, 
how good is it according to an optimal policy? 
Value Iteration
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Optimal Policy
Expectimax trees max over all actions to compute the optimal values
a
s
s, a
s,a,sâ€™
â€™s
Ï€(s)
s
s, Ï€(s)
s, Ï€(s),sâ€™
â€™s
Do the optimal action
Do what Ï€ says to do
Optimal Quantities
â–ªThe value (utility) of a state s:
V*(s) = expected utility starting in s and 
acting optimally
â–ªThe value (utility) of a q-state (s,a):
Q*(s,a) = expected utility starting out 
having taken action a from state s and 
(thereafter) acting optimally
â–ªThe optimal policy:
Ï€*(s) = optimal action from state s
a
s
â€™s
s, a
(s,a,sâ€™) is a 
transition
s,a,sâ€™
s is a 
state
(s, a) is a 
q-state
 
Optimal Values of States
â–ªFundamental operation: compute the (expectimax) value of a state
â–ªExpected utility under optimal action
â–ªAverage sum of (discounted) rewards
â–ªThis is just what expectimax computed!
â–ªRecursive definition of optimal values:
a
s
s, a
s,a,sâ€™
â€™s
 
 
 
 
Bellman Equations
â–ªRecursive definition of value: 
â–ªBellman Equation: 
Necessary condition for optimality in optimization problems 
formulated as Dynamic Programming
â–ªDynamic Programing:
Process to simplify an optimization problem by breaking it 
down into an optimal substructure.
Richard E. Bellman
       (1920â€“1984)
 
Policy Evaluation
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
Iterative Approach
Value Iteration
 
 
 
Value Iteration
 
 
 
 
 
 
 
 
 
 
 
 
Policy Evaluation
 
Evaluate an optimal policy
t=0
 
 
Noise = 0.2
Discount = 0.9
Living reward = 0
t=1
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=2
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=3
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=4
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=5
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=6
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=7
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
t=100
Noise = 0.2
Discount = 0.9
Living reward = 0
 
 
 
 
 
Policy Extraction
Computing Actions from Values
â–ªLetâ€™s imagine we have the optimal values V*(s)
â–ªHow should we act?
â–ªItâ€™s not obvious!
â–ªWe need to do a mini-expectimax (one step)
â–ªThis is called policy extraction, since it gets the policy implied by the values
 
Computing Actions from Q-Values
â–ªLetâ€™s imagine we have the optimal q-values:
â–ªHow should we act?
â–ªCompletely trivial to decide!
â–ªImportant lesson: actions are easier to select from q-values than values!
 
 
The Bellman Equations
â–ªDefinition of â€œoptimal utilityâ€ via expectimax recurrence 
gives a simple one-step lookahead relationship amongst 
optimal utility values
a
s
s, a
s,a,sâ€™
â€™s
 
 
How to be optimal:
  Step 1: Take correct first action
  Step 2: Keep being optimal
 
Value Iteration
â–ªBellman equations characterize the optimal values:
â–ªValue iteration computes them:
a
V(s)
s, a
s,a,sâ€™
V(sâ€™)
 
 
Policy Iteration
Problems with Value Iteration
â–ªValue iteration repeats the Bellman updates:
â–ªProblem 1: Itâ€™s slow â€“ O(S2A) per iteration
â–ªProblem 2: The â€œmaxâ€ at each state rarely changes
â–ªProblem 3: The policy often converges long before the values
a
s
s, a
s,a,sâ€™
â€™s
 
t=0
Noise = 0.2
Discount = 0.9
Living reward = 0
t=1
Noise = 0.2
Discount = 0.9
Living reward = 0
t=2
Noise = 0.2
Discount = 0.9
Living reward = 0
t=3
Noise = 0.2
Discount = 0.9
Living reward = 0
t=4
Noise = 0.2
Discount = 0.9
Living reward = 0
t=5
Noise = 0.2
Discount = 0.9
Living reward = 0
t=6
Noise = 0.2
Discount = 0.9
Living reward = 0
t=7
Noise = 0.2
Discount = 0.9
Living reward = 0
t=8
Noise = 0.2
Discount = 0.9
Living reward = 0
t=9
Noise = 0.2
Discount = 0.9
Living reward = 0
t=10
Noise = 0.2
Discount = 0.9
Living reward = 0
t=11
Noise = 0.2
Discount = 0.9
Living reward = 0
t=12
Noise = 0.2
Discount = 0.9
Living reward = 0
t=100
Noise = 0.2
Discount = 0.9
Living reward = 0
Policy Iteration
â–ªAlternative approach for optimal values:
â–ªStep 1: Policy evaluation: calculate utilities for some fixed policy (not optimal 
utilities!) until convergence
â–ªStep 2: Policy improvement: update policy using one-step look-ahead with resulting 
converged (but not optimal!) utilities as future values
â–ªRepeat steps until policy converges
â–ªThis is policy iteration
â–ªItâ€™s still optimal!
â–ªCan converge (much) faster under some conditions
Policy Iteration
â–ª 
 
 
Policy Evaluation - t=0, t=1
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Evaluation - t=1, t=2
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Evaluation - t=2, t=3
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Evaluation - t=3, t=4
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Evaluation - t=4, t=5
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Evaluation - t=5, t=6
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Improvement â€“ t=6
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Policy Improvement â€“ Policy Evaluation
Noise = 0.2
Discount = 0.9
Living reward = 0
 
Comparison
â–ªBoth value iteration and policy iteration compute the same thing (all optimal values)
â–ªIn value iteration:
â–ªEvery iteration updates both the values and (implicitly) the policy
â–ªWe donâ€™t track the policy, but taking the max over actions implicitly recomputes it
â–ªIn policy iteration:
â–ªWe do several passes that update utilities with fixed policy (each pass is fast because we 
consider only one action, not all of them)
â–ªAfter the policy is evaluated, a new policy is chosen (slow like a value iteration pass)
â–ªThe new policy will be better (or weâ€™re done)
â–ªBoth are dynamic programs for solving MDPs
